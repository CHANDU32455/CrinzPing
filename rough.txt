import json
import boto3
import os
import traceback
from decimal import Decimal
from boto3.dynamodb.conditions import Key, Attr

# DynamoDB & S3 clients
dynamodb = boto3.resource("dynamodb")
s3_client = boto3.client("s3")

TABLE_NAME = os.environ.get("CRINZ_DYNAMO_TABLE", "CrinzContent")
USER_DETAILS_TABLE = dynamodb.Table("UserDetails")
LIKES_TABLE = dynamodb.Table("CrinzLikes")
BUCKET_NAME = os.environ.get("CRINZ_S3_BUCKET", "crinzcontent")
PROFILE_PICS_BUCKET = "userprofilepicsbucket-crinzping"
table = dynamodb.Table(TABLE_NAME)

# Helper functions
def convert_decimals(obj):
    if isinstance(obj, list):
        return [convert_decimals(i) for i in obj]
    elif isinstance(obj, dict):
        return {k: convert_decimals(v) for k, v in obj.items()}
    elif isinstance(obj, Decimal):
        return float(obj)
    else:
        return obj

def get_signed_url(bucket, key):
    """Generate presigned URL for S3 object"""
    if not key:
        return ""
    try:
        return s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': bucket, 'Key': key},
            ExpiresIn=3600
        )
    except Exception as e:
        print(f"Error generating signed URL for {key}: {str(e)}")
        return ""

def get_profile_pic_url(user_id, profile_pic_path):
    """Generate profile picture URL"""
    if not profile_pic_path:
        return get_signed_url(PROFILE_PICS_BUCKET, f"profile-pics/{user_id}.jpg")
    if profile_pic_path.startswith("profile-pics/"):
        return get_signed_url(PROFILE_PICS_BUCKET, profile_pic_path)
    return get_signed_url(PROFILE_PICS_BUCKET, f"profile-pics/{profile_pic_path}")

def fetch_user_details(user_ids):
    """Fetch user details (username, profile pic, tagline) for multiple users"""
    users = {}
    if not user_ids:
        return users
        
    unique_user_ids = list(set(user_ids))
    
    try:
        # Batch get user details
        keys = [{"userId": uid} for uid in unique_user_ids]
        
        for i in range(0, len(keys), 100):
            batch_keys = keys[i:i+100]
            response = dynamodb.batch_get_item(
                RequestItems={
                    USER_DETAILS_TABLE.name: {'Keys': batch_keys}
                }
            )
            
            for item in response.get('Responses', {}).get(USER_DETAILS_TABLE.name, []):
                uid = item["userId"]
                users[uid] = {
                    "userName": item.get("displayName", uid[:8]),  # Fallback to user ID
                    "profilePic": get_profile_pic_url(uid, item.get("profilePicPath")),
                    "tagline": item.get("Tagline", "")
                }
        
        print(f"Fetched details for {len(users)} users")
        
    except Exception as e:
        print(f"Error fetching user details: {e}")
        
    return users

def check_user_likes(user_id, content_ids):
    """Check if user has liked specific content items"""
    if not user_id or not content_ids:
        return {}
    
    liked_items = {}
    
    try:
        # Batch get likes for all content items
        keys = [{"crinzId": content_id, "userId": user_id} for content_id in content_ids]
        
        for i in range(0, len(keys), 100):
            batch_keys = keys[i:i+100]
            response = dynamodb.batch_get_item(
                RequestItems={
                    LIKES_TABLE.name: {'Keys': batch_keys}
                }
            )
            
            # If item exists in likes table, user has liked it
            for item in response.get('Responses', {}).get(LIKES_TABLE.name, []):
                liked_items[item["crinzId"]] = True
                
        print(f"Checked likes for {len(content_ids)} items, found {len(liked_items)} likes by user {user_id}")
        
    except Exception as e:
        print(f"Error checking user likes: {e}")
        
    return liked_items

def lambda_handler(event, context):
    try:
        # Parse incoming body
        body_str = event.get("body", "{}")
        body = json.loads(body_str)

        limit = int(body.get("limit", 10))
        last_key = body.get("lastKey")
        search_term = body.get("searchTerm", "").lower()

        # Extract user ID from JWT claims
        claims = event.get("requestContext", {}).get("authorizer", {}).get("jwt", {}).get("claims", {})
        user_id = claims.get("sub")
        
        if not user_id:
            return {
                "statusCode": 401,
                "body": json.dumps({"error": "Unauthorized - User ID not found"}),
                "headers": {
                    "Content-Type": "application/json",
                    "Access-Control-Allow-Origin": "*",
                }
            }

        # Build filter expression for reels only
        filter_expression = Attr("type").eq("crinzpostsreels")
        if search_term:
            filter_expression &= (
                Attr("caption").contains(search_term) | Attr("tags").contains(search_term)
            )

        scan_kwargs = {
            "FilterExpression": filter_expression,
            "Limit": limit,
        }

        if last_key:
            scan_kwargs["ExclusiveStartKey"] = last_key

        response = table.scan(**scan_kwargs)

        items = response.get("Items", [])
        last_evaluated_key = response.get("LastEvaluatedKey")

        print(f"Found {len(items)} reels for user {user_id}")

        # Extract user IDs for fetching user details
        user_ids = list(set(item.get("userId") for item in items if item.get("userId")))
        user_details_map = fetch_user_details(user_ids)

        # Extract content IDs for checking likes
        content_ids = [item.get("postId") for item in items if item.get("postId")]
        user_likes_map = check_user_likes(user_id, content_ids)

        # Process each reel
        processed_reels = []
        for item in items:
            files = item.get("files", [])
            user_id_val = item.get("userId")
            
            # Generate presigned URLs for S3 files
            for f in files:
                s3_key = f.get("s3Key")
                if s3_key:
                    try:
                        presigned_url = s3_client.generate_presigned_url(
                            "get_object",
                            Params={"Bucket": BUCKET_NAME, "Key": s3_key},
                            ExpiresIn=3600  # 1 hour
                        )
                        f["presignedUrl"] = presigned_url
                    except Exception as e:
                        print(f"Error generating presigned URL for {s3_key}: {str(e)}")
                        f["presignedUrl"] = None
            
            # Add convenience fields
            thumbnails = [f for f in files if f.get("type", "").startswith("image/")]
            if thumbnails:
                item["thumbnail"] = thumbnails[0]
            else:
                videos = [f for f in files if f.get("type", "").startswith("video/")]
                if videos:
                    item["thumbnail"] = videos[0]

            # Build the complete reel object
            reel = {
                "postId": item.get("postId"),
                "userId": user_id_val,
                "caption": item.get("caption", ""),
                "tags": item.get("tags", []),
                "timestamp": item.get("timestamp", 0),
                "likes": int(item.get("likes", 0)),
                "comments": int(item.get("comments", 0)),
                "visibility": item.get("visibility", "public"),
                "files": files,
                # Add user profile information
                "user": user_details_map.get(user_id_val, {
                    "userName": user_id_val[:8] if user_id_val else "Unknown",
                    "profilePic": "",
                    "tagline": ""
                }),
                # Add like status for current user
                "isLikedByUser": user_likes_map.get(item.get("postId"), False)
            }
            
            processed_reels.append(reel)

        # Convert Decimals to floats for JSON
        processed_reels = convert_decimals(processed_reels)
        last_evaluated_key = convert_decimals(last_evaluated_key)

        print(f"Returning {len(processed_reels)} reels with user details and like status")

        return {
            "statusCode": 200,
            "body": json.dumps({
                "reels": processed_reels,
                "lastEvaluatedKey": last_evaluated_key,
                "userDetailsFetched": len(user_details_map),
                "likesChecked": len(user_likes_map)
            }),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            }
        }

    except Exception as e:
        print(f"Error: {str(e)}")
        traceback.print_exc()
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)}),
            "headers": {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
            },
        }