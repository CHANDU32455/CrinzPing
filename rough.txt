import { useState, type ChangeEvent, useRef, useEffect, useCallback } from "react";
import { VideoCompressionUtility } from "../utils/reelsCompressionUtil";
import type { CompressionResult } from "../utils/reelsCompressionUtil";
import { useAuth } from "react-oidc-context";

// Define types for our states
type UploadState = 'idle' | 'getting_url' | 'getting_video_url' | 'uploading' | 'uploading_video' | 'uploading_thumbnail' | 'saving_metadata' | 'completed' | 'error';
type ProcessingState = 'idle' | 'processing' | 'completed' | 'error';
type ThumbnailState = 'idle' | 'generating' | 'ready' | 'error';

// Updated validation constants
const MAX_SIZE_MB = 100; // Increased to 100MB
const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;
const MAX_CAPTION_LENGTH = 200;
const MAX_TAG_LENGTH = 100;
const MAX_TAGS_COUNT = 20; // Reduced to 20 tags

// Props interface
interface CreateReelProps {
    editData?: {
        postId?: string;
        reelId?: string;
        caption?: string;
        tags?: string[];
        visibility?: "public" | "private";
        videoUrl?: string;
        thumbnailUrl?: string;
        fileName?: string;
        fileType?: string;
        isEditMode?: boolean;
        cachedVideo?: File;
        existingVideo?: any;
        existingThumbnail?: any;
        allFiles?: any[];
    };
    onSave?: (data: any) => void;
    onCancel?: () => void;
    isModal?: boolean;
}

export default function CreateReel({ editData, onSave, onCancel, isModal = false }: CreateReelProps) {
    const auth = useAuth();
    const access_token = auth.user?.access_token;

    // Initialize state with editData if available
    const [video, setVideo] = useState<File | null>(null);
    const [processedVideo, setProcessedVideo] = useState<File | null>(null);
    const [videoDuration, setVideoDuration] = useState<number>(0);
    const [caption, setCaption] = useState(editData?.caption || "");
    const [tags, setTags] = useState(editData?.tags?.join(', ') || "");
    const [previewMode, setPreviewMode] = useState(false);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [processingState, setProcessingState] = useState<ProcessingState>('idle');
    const [processingProgress, setProcessingProgress] = useState(0);
    const [processingResult, setProcessingResult] = useState<CompressionResult | null>(null);
    const [visibility, setVisibility] = useState<"public" | "private">(editData?.visibility || "public");
    const [uploadState, setUploadState] = useState<UploadState>('idle');
    const [uploadProgress, setUploadProgress] = useState(0);
    const [errors, setErrors] = useState({
        video: "",
        caption: "",
        tags: ""
    });

    const videoObjectUrl = useRef<string | null>(null);
    const processedVideoUrl = useRef<string | null>(null);
    const thumbnailObjectUrl = useRef<string | null>(null);
    const [thumbnail, setThumbnail] = useState<File | null>(null);
    const [thumbnailState, setThumbnailState] = useState<ThumbnailState>('idle');
    const [thumbnailPreview, setThumbnailPreview] = useState<string | null>(editData?.thumbnailUrl || null);

    // Blob URL cleanup function
    const cleanupBlobUrls = useCallback(() => {
        if (videoObjectUrl.current) URL.revokeObjectURL(videoObjectUrl.current);
        if (processedVideoUrl.current) URL.revokeObjectURL(processedVideoUrl.current);
        videoObjectUrl.current = null;
        processedVideoUrl.current = null;
    }, []);

    // Cleanup effect
    useEffect(() => {
        return () => {
            cleanupBlobUrls();
            if (thumbnailObjectUrl.current) URL.revokeObjectURL(thumbnailObjectUrl.current);
        };
    }, [cleanupBlobUrls]);

    // Edit mode initialization
    useEffect(() => {
        if (editData?.isEditMode && editData.cachedVideo && !videoObjectUrl.current) {
            console.log('üé¨ Using cached video file for editing');

            // Create blob URLs
            cleanupBlobUrls();
            videoObjectUrl.current = URL.createObjectURL(editData.cachedVideo);
            processedVideoUrl.current = videoObjectUrl.current;

            setVideo(editData.cachedVideo);
            setProcessedVideo(editData.cachedVideo);

            setProcessingState('completed');
            setProcessingResult({
                file: editData.cachedVideo,
                originalSize: editData.cachedVideo.size,
                processedSize: editData.cachedVideo.size,
                timeTaken: 0,
                quality: 100,
                resolution: 'existing'
            });

            // Get video duration
            const videoElement = document.createElement('video');
            videoElement.src = videoObjectUrl.current;
            videoElement.addEventListener('loadedmetadata', () => {
                setVideoDuration(videoElement.duration);
                console.log('‚è±Ô∏è Video duration:', videoElement.duration);
            });

        } else if (editData?.isEditMode && editData.videoUrl && !videoObjectUrl.current) {
            console.log('üìπ Using video URL for editing (no cache)');
            videoObjectUrl.current = editData.videoUrl;

            setProcessingState('completed');
            setProcessingResult({
                file: new File([], 'existing-video.mp4'),
                originalSize: 0,
                processedSize: 0,
                timeTaken: 0,
                quality: 100,
                resolution: 'existing'
            });
        }

        // Set thumbnail if available
        if (editData?.isEditMode && editData.thumbnailUrl && !thumbnailPreview) {
            setThumbnailPreview(editData.thumbnailUrl);
            console.log('üñºÔ∏è Set existing thumbnail:', editData.thumbnailUrl);
        }
    }, [editData, cleanupBlobUrls, thumbnailPreview]);

    // Custom SVG Icons
    const VideoIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <polygon points="23,7 16,12 23,17 23,7" stroke="currentColor" strokeWidth="2" fill="none" />
            <rect x="1" y="5" width="15" height="14" rx="2" stroke="currentColor" strokeWidth="2" />
        </svg>
    );

    const EditIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <path d="M11 4H4C2.89543 4 2 4.89543 2 6V20C2 21.1046 2.89543 22 4 22H18C19.1046 22 20 21.1046 20 20V13" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
            <path d="M18.5 2.5C19.3284 1.67157 20.6716 1.67157 21.5 2.5C22.3284 3.32843 22.3284 4.67157 21.5 5.5L12 15L8 16L9 12L18.5 2.5Z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
        </svg>
    );

    const SendIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <line x1="22" y1="2" x2="11" y2="13" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
            <polygon points="22,2 15,22 11,13 2,9 22,2" stroke="currentColor" strokeWidth="2" fill="none" />
        </svg>
    );

    const EyeIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <path d="M1 12C1 12 5 4 12 4C19 4 23 12 23 12C23 12 19 20 12 20C5 20 1 12 1 12Z" stroke="currentColor" strokeWidth="2" />
            <circle cx="12" cy="12" r="3" stroke="currentColor" strokeWidth="2" />
        </svg>
    );

    const CloseIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <line x1="18" y1="6" x2="6" y2="18" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
            <line x1="6" y1="6" x2="18" y2="18" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
        </svg>
    );

    const ImageIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" className="flex-shrink-0">
            <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" strokeWidth="2" />
            <circle cx="8.5" cy="8.5" r="1.5" fill="currentColor" />
            <path d="M21 15L16 10L5 21" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
        </svg>
    );

    const generateThumbnail = async (videoFile: File, timeInSeconds: number = 0.2): Promise<File | null> => {
        return new Promise((resolve) => {
            const videoElement = document.createElement('video');
            const objectUrl = URL.createObjectURL(videoFile);
            videoElement.src = objectUrl;

            videoElement.addEventListener('loadedmetadata', () => {
                videoElement.currentTime = Math.min(timeInSeconds, videoElement.duration);
            });

            videoElement.addEventListener('seeked', () => {
                const canvas = document.createElement('canvas');
                const maxDimension = 800;
                let width = videoElement.videoWidth;
                let height = videoElement.videoHeight;

                if (width > height) {
                    if (width > maxDimension) {
                        height = Math.round((height * maxDimension) / width);
                        width = maxDimension;
                    }
                } else {
                    if (height > maxDimension) {
                        width = Math.round((width * maxDimension) / height);
                        height = maxDimension;
                    }
                }

                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.drawImage(videoElement, 0, 0, width, height);

                    const targetMaxSize = 500 * 1024;
                    let quality = 0.85;

                    const tryConvert = (q: number) => {
                        canvas.toBlob((blob) => {
                            if (blob) {
                                if (blob.size > targetMaxSize && q > 0.5) {
                                    tryConvert(q - 0.1);
                                } else {
                                    const fileName = `thumbnail-${Date.now()}.jpg`;
                                    const file = new File([blob], fileName, { type: 'image/jpeg' });
                                    URL.revokeObjectURL(objectUrl);
                                    resolve(file);
                                }
                            } else {
                                URL.revokeObjectURL(objectUrl);
                                resolve(null);
                            }
                        }, 'image/jpeg', q);
                    };
                    tryConvert(quality);
                } else {
                    URL.revokeObjectURL(objectUrl);
                    resolve(null);
                }
            });

            videoElement.addEventListener('error', () => {
                URL.revokeObjectURL(objectUrl);
                resolve(null);
            });
        });
    };

    const VisibilityToggle = () => {
        const isPublic = visibility === "public";
        const handleToggle = () => setVisibility(isPublic ? "private" : "public");

        return (
            <div className="flex items-center gap-3 mb-4">
                <span className="text-sm text-gray-400">Visibility:</span>
                <button
                    type="button"
                    onClick={handleToggle}
                    className={`px-4 py-2 rounded-lg font-medium text-sm transition-colors
          ${isPublic ? "bg-green-500 text-white" : "bg-gray-500 text-white"}
        `}
                    title={isPublic ? "Visible to everyone globally" : "Visible only to friends"}
                >
                    {isPublic ? "üåç Public" : "üîí Protected"}
                </button>
            </div>
        );
    };

    const formatBytes = (bytes: number): string => {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    const formatTime = (seconds: number): string => {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const validateForm = () => {
        const newErrors = {
            video: !video && !editData?.isEditMode ? "A video is required" : "",
            caption: caption.trim().length === 0
                ? "Caption is required"
                : caption.length > MAX_CAPTION_LENGTH
                    ? `Caption cannot exceed ${MAX_CAPTION_LENGTH} characters`
                    : "",
            tags: ""
        };

        const tagList = tags.split(',')
            .map(tag => tag.trim())
            .filter(tag => tag.length > 0);

        if (tagList.length === 0) {
            newErrors.tags = "At least one tag is required";
        } else {
            for (let tag of tagList) {
                if (tag.length > MAX_TAG_LENGTH) {
                    newErrors.tags = `Each tag cannot exceed ${MAX_TAG_LENGTH} characters`;
                    break;
                }
            }
            if (tagList.length > MAX_TAGS_COUNT) {
                newErrors.tags = `You can use up to ${MAX_TAGS_COUNT} tags only`;
            }
        }

        setErrors(newErrors);
        return !Object.values(newErrors).some(error => error !== "");
    };

    const validateVideo = (file: File): string => {
        if (file.size > MAX_SIZE_BYTES) {
            return `Video is too large (${formatBytes(file.size)}). Maximum allowed size is ${MAX_SIZE_MB}MB.`;
        }
        if (file.size === 0) {
            return "Video file is empty (0 KB)";
        }
        return "";
    };

    const handleVideoChange = async (e: ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            const file = e.target.files[0];

            // Basic validation
            const validationError = validateVideo(file);
            if (validationError) {
                setErrors({ ...errors, video: validationError });
                return;
            }

            setVideo(file);
            setProcessedVideo(null);
            setProcessingState('processing');
            setProcessingProgress(0);
            setProcessingResult(null);
            setErrors({ ...errors, video: "" });

            // Create preview URL
            cleanupBlobUrls();
            videoObjectUrl.current = URL.createObjectURL(file);

            try {
                // Get duration for preview
                const duration = await getVideoDuration(file);
                setVideoDuration(duration);
                console.log(`üìπ Original video: ${file.name}, Size: ${formatBytes(file.size)}, Duration: ${duration.toFixed(2)}s`);

                // Generate thumbnail
                setThumbnailState('generating');
                const thumb = await generateThumbnail(file);
                if (thumb) {
                    setThumbnail(thumb);
                    if (thumbnailObjectUrl.current) URL.revokeObjectURL(thumbnailObjectUrl.current);
                    thumbnailObjectUrl.current = URL.createObjectURL(thumb);
                    setThumbnailPreview(thumbnailObjectUrl.current);
                    setThumbnailState('ready');
                } else {
                    setThumbnailState('error');
                }

                // üöÄ Use SMART compression - handles everything automatically
                console.log('üéØ Starting SMART video compression...');
                const result = await VideoCompressionUtility.smartCompress(
                    file,
                    (progress) => setProcessingProgress(progress)
                );

                // Set the processed video
                setProcessedVideo(result.file);
                setProcessingResult(result);

                // Create preview URL for processed video
                processedVideoUrl.current = URL.createObjectURL(result.file);

                setProcessingState('completed');
                console.log('‚úÖ SMART compression completed successfully!');

            } catch (error) {
                console.error('‚ùå Compression failed:', error);
                setErrors({ ...errors, video: "Compression failed. Please try another video." });
                setProcessingState('error');

                // Fallback: use original file
                setProcessedVideo(file);
                setProcessingResult({
                    file,
                    originalSize: file.size,
                    processedSize: file.size,
                    timeTaken: 0,
                    quality: 100,
                    resolution: 'original'
                });
            }
        }
    };

    // Helper function to get video duration
    const getVideoDuration = (file: File): Promise<number> => {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            const url = URL.createObjectURL(file);
            video.src = url;
            video.addEventListener('loadedmetadata', () => {
                resolve(video.duration);
                URL.revokeObjectURL(url);
            });
            video.addEventListener('error', () => {
                resolve(0);
                URL.revokeObjectURL(url);
            });
        });
    };

    const compressImage = async (file: File, maxSizeKB: number = 500): Promise<File> => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const objectUrl = URL.createObjectURL(file);

            img.onload = () => {
                URL.revokeObjectURL(objectUrl);
                const maxDimension = 800;
                let width = img.width;
                let height = img.height;

                if (width > height) {
                    if (width > maxDimension) {
                        height = Math.round((height * maxDimension) / width);
                        width = maxDimension;
                    }
                } else {
                    if (height > maxDimension) {
                        width = Math.round((width * maxDimension) / height);
                        height = maxDimension;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    reject(new Error('Could not get canvas context'));
                    return;
                }

                ctx.drawImage(img, 0, 0, width, height);

                const tryCompress = (quality: number) => {
                    canvas.toBlob((blob) => {
                        if (!blob) {
                            reject(new Error('Failed to create blob'));
                            return;
                        }
                        const sizeKB = blob.size / 1024;
                        if (sizeKB > maxSizeKB && quality > 0.5) {
                            tryCompress(quality - 0.1);
                        } else {
                            const fileName = file.name.replace(/\.[^/.]+$/, "") || 'thumbnail';
                            const newFile = new File([blob], `${fileName}-compressed.jpg`, { type: 'image/jpeg' });
                            resolve(newFile);
                        }
                    }, 'image/jpeg', quality);
                };
                tryCompress(0.8);
            };

            img.onerror = () => {
                URL.revokeObjectURL(objectUrl);
                reject(new Error('Failed to load image'));
            };
            img.src = objectUrl;
        });
    };

    const handleThumbnailChange = async (e: ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            const file = e.target.files[0];
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file for thumbnail');
                return;
            }

            const maxSizeBytes = 1024 * 1024;
            if (file.size > maxSizeBytes) {
                setThumbnailState('generating');
                try {
                    const compressedFile = await compressImage(file);
                    setThumbnail(compressedFile);
                    if (thumbnailObjectUrl.current) URL.revokeObjectURL(thumbnailObjectUrl.current);
                    thumbnailObjectUrl.current = URL.createObjectURL(compressedFile);
                    setThumbnailPreview(thumbnailObjectUrl.current);
                    setThumbnailState('ready');
                } catch (error) {
                    console.error('Error compressing thumbnail:', error);
                    setThumbnailState('error');
                    alert('Failed to process thumbnail. Please try another image.');
                }
            } else {
                setThumbnail(file);
                if (thumbnailObjectUrl.current) URL.revokeObjectURL(thumbnailObjectUrl.current);
                thumbnailObjectUrl.current = URL.createObjectURL(file);
                setThumbnailPreview(thumbnailObjectUrl.current);
                setThumbnailState('ready');
            }
        }
    };

    const removeThumbnail = () => {
        setThumbnail(null);
        setThumbnailPreview(null);
        setThumbnailState('idle');
        if (thumbnailObjectUrl.current) {
            URL.revokeObjectURL(thumbnailObjectUrl.current);
            thumbnailObjectUrl.current = null;
        }
    };

    const handleCaptionChange = (e: ChangeEvent<HTMLTextAreaElement>) => {
        const value = e.target.value;
        if (value.length <= MAX_CAPTION_LENGTH) {
            setCaption(value);
            setErrors(prev => ({ ...prev, caption: "" }));
        }
    };

    const handleTagsChange = (e: ChangeEvent<HTMLInputElement>) => {
        const value = e.target.value;
        setTags(value);
        setErrors(prev => ({ ...prev, tags: "" }));
    };

    const removeVideo = () => {
        setVideo(null);
        setProcessedVideo(null);
        setProcessingState('idle');
        setProcessingProgress(0);
        setProcessingResult(null);
        setVideoDuration(0);
        setThumbnail(null);
        setThumbnailPreview(null);
        setThumbnailState('idle');
        cleanupBlobUrls();
        if (thumbnailObjectUrl.current) URL.revokeObjectURL(thumbnailObjectUrl.current);
    };

    const handlePreview = () => {
        if (validateForm()) {
            setPreviewMode(true);
        }
    };

    // Enhanced handleSubmit for both create and edit
    const handleSubmit = async () => {
        // For edit mode, return data to parent
        if (editData?.isEditMode && onSave) {
            setIsSubmitting(true);
            setUploadState('getting_url');

            try {
                console.log('üíæ Starting reel update process...');

                const updatedData = {
                    postId: editData.postId,
                    reelId: editData.reelId,
                    caption,
                    tags: tags.split(',').map(t => t.trim()).filter(t => t.length > 0),
                    visibility,
                    video: processedVideo, // New video file if replaced
                    thumbnail: thumbnail, // New thumbnail file if replaced
                    videoUrl: editData.videoUrl, // Keep existing URL
                    thumbnailUrl: editData.thumbnailUrl // Keep existing URL
                };

                console.log('üíæ Saving edited reel:', updatedData);

                // Simulate processing for better UX
                setUploadState('saving_metadata');
                await new Promise(resolve => setTimeout(resolve, 800));

                setUploadState('completed');
                await new Promise(resolve => setTimeout(resolve, 300));

                onSave(updatedData);

            } catch (error) {
                console.error('Update failed:', error);
                setUploadState('error');
                alert('Failed to update reel. Please try again.');
            } finally {
                setIsSubmitting(false);
            }
            return;
        }

        // Original create logic
        if (!processedVideo) {
            alert("No video selected");
            return;
        }
        if (!access_token) {
            alert("Not authenticated");
            return;
        }

        setIsSubmitting(true);
        setUploadState('getting_url');

        try {
            console.log("1. Requesting presigned URL for video...");
            setUploadState('getting_video_url');

            const safeVideoFilename = encodeURIComponent(processedVideo.name);

            const videoPresignRes = await fetch(`${import.meta.env.VITE_BASE_API_URL}/reelContentUploader`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${access_token}`,
                },
                body: JSON.stringify({
                    filename: safeVideoFilename,
                    filetype: processedVideo.type,
                    purpose: "reel_video"
                }),
            });

            if (!videoPresignRes.ok) {
                throw new Error(`Failed to get video presigned URL: ${videoPresignRes.status}`);
            }

            const videoPresignData = await videoPresignRes.json();
            const { url: videoPresignedUrl, key: videoS3Key, reelId } = videoPresignData;

            console.log("2. Uploading video to S3...");
            setUploadState('uploading_video');

            // Upload video
            await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.upload.addEventListener("progress", (event) => {
                    if (event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        setUploadProgress(percentComplete);
                    }
                });
                xhr.open("PUT", videoPresignedUrl);
                xhr.setRequestHeader("Content-Type", processedVideo.type);
                xhr.onload = () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve(true);
                    } else {
                        reject(new Error(`Video upload failed: ${xhr.status}`));
                    }
                };
                xhr.onerror = () => reject(new Error("Network error during video upload"));
                xhr.send(processedVideo);
            });

            let thumbnailS3Key = null;

            // Upload thumbnail if available
            if (thumbnail) {
                console.log("3. Uploading thumbnail...");
                setUploadState('uploading_thumbnail');

                const safeThumbnailFilename = encodeURIComponent(thumbnail.name);
                const thumbnailPresignRes = await fetch(`${import.meta.env.VITE_BASE_API_URL}/reelContentUploader`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: `Bearer ${access_token}`,
                    },
                    body: JSON.stringify({
                        filename: safeThumbnailFilename,
                        filetype: thumbnail.type,
                        purpose: "reel_thumbnail",
                        reelId: reelId
                    }),
                });

                if (thumbnailPresignRes.ok) {
                    const thumbnailPresignData = await thumbnailPresignRes.json();
                    const { url: thumbnailPresignedUrl, key: thumbS3Key } = thumbnailPresignData;

                    await new Promise((resolve) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open("PUT", thumbnailPresignedUrl);
                        xhr.setRequestHeader("Content-Type", thumbnail.type);
                        xhr.onload = () => {
                            if (xhr.status >= 200 && xhr.status < 300) {
                                thumbnailS3Key = thumbS3Key;
                                resolve(true);
                            } else {
                                console.warn("Thumbnail upload failed");
                                resolve(false);
                            }
                        };
                        xhr.onerror = () => {
                            console.warn("Network error during thumbnail upload");
                            resolve(false);
                        };
                        xhr.send(thumbnail);
                    });
                }
            }

            console.log("4. Saving metadata...");
            setUploadState('saving_metadata');

            const metadataPayload = {
                action: "REELCREATE",
                metadata: {
                    from: "crinzpostsreels",
                    reelFile: {
                        s3Key: videoS3Key,
                        fileName: processedVideo.name,
                        type: processedVideo.type
                    },
                    caption: caption,
                    tags: tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0).join(','),
                    visibility: visibility,
                    reelId: reelId,
                    ...(thumbnailS3Key ? {
                        thumbnail: {
                            s3Key: thumbnailS3Key,
                            fileName: thumbnail?.name || "thumbnail.jpg",
                            type: thumbnail?.type || "image/jpeg",
                            isCustom: !!thumbnail
                        }
                    } : {})
                }
            };

            const metadataRes = await fetch(`${import.meta.env.VITE_BASE_API_URL}/addCrinzMemePost`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    Authorization: `Bearer ${access_token}`,
                },
                body: JSON.stringify(metadataPayload),
            });

            if (!metadataRes.ok) {
                throw new Error(`Metadata save failed: ${metadataRes.status}`);
            }

            setUploadState('completed');
            setTimeout(() => {
                // Reset form
                setVideo(null);
                setProcessedVideo(null);
                setThumbnail(null);
                setThumbnailPreview(null);
                setCaption("");
                setTags("");
                setIsSubmitting(false);
                setPreviewMode(false);
                setUploadState('idle');
                setUploadProgress(0);
                cleanupBlobUrls();
            }, 1000);

        } catch (err: any) {
            console.error("Upload error:", err);
            setUploadState('error');
            setIsSubmitting(false);
            alert(`Failed to submit reel: ${err.message}`);
        }
    };

    const CacheStatus = () => {
        if (!editData?.isEditMode) return null;

        return (
            <div className="p-3 bg-blue-900/20 border border-blue-700/30 rounded-lg mb-4">
                <div className="flex items-center gap-2 text-sm">
                    <span className={`w-2 h-2 rounded-full ${editData.cachedVideo ? 'bg-green-500' : 'bg-blue-500'}`}></span>
                    <span className="text-blue-300">
                        {editData.cachedVideo ? 'Video cached locally' : 'Streaming from cloud'}
                    </span>
                    {!editData.cachedVideo && (
                        <span className="text-blue-400 text-xs">(Limited editing features)</span>
                    )}
                </div>
            </div>
        );
    };

    // Add cancel button for modal mode
    const renderActions = () => {
        if (isModal) {
            return (
                <div className="flex gap-3 justify-end mt-6 pt-4 border-t border-gray-700">
                    <button
                        onClick={onCancel}
                        className="px-6 py-2 bg-gray-600 rounded-lg hover:bg-gray-500 transition-colors"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={handlePreview}
                        disabled={(!video && !editData?.isEditMode) || processingState === 'processing' || !processedVideo}
                        className="px-6 py-2 bg-blue-600 rounded-lg hover:bg-blue-500 transition-colors disabled:opacity-50"
                    >
                        {editData?.isEditMode ? 'Preview Changes' : 'Preview Reel'}
                    </button>
                </div>
            );
        }

        return (
            <button
                onClick={handlePreview}
                disabled={(!video && !editData?.isEditMode) || processingState === 'processing' || !processedVideo}
                className="w-full mt-6 py-3 rounded-2xl bg-gradient-to-r from-blue-600 to-purple-600 text-white hover:from-blue-700 hover:to-purple-700 shadow-lg hover:shadow-blue-500/20 text-lg font-medium flex items-center justify-center gap-2 transition-all disabled:opacity-50 disabled:cursor-not-allowed"
            >
                <EyeIcon />
                {processingState === 'processing' ? 'Processing...' : (editData?.isEditMode ? 'Preview Changes' : 'Preview Reel')}
            </button>
        );
    };

    if (previewMode) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-gray-900 to-black">
                <div className="max-w-4xl mx-auto relative">
                    <button
                        onClick={() => setPreviewMode(false)}
                        className="absolute -top-2 -right-2 z-10 p-2 bg-red-600 text-white rounded-full hover:bg-red-700 shadow-lg transition-all"
                    >
                        <CloseIcon />
                    </button>

                    <div className="bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 overflow-hidden transition-all duration-300 hover:shadow-blue-500/10">
                        <div className="h-2 bg-gradient-to-r from-blue-600 to-purple-600"></div>

                        <div className="p-6">
                            <div className="mb-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                                        {editData?.isEditMode ? 'Preview Changes' : 'Preview Reel'}
                                    </h2>
                                    <span className={`px-3 py-1 rounded-full text-xs font-medium ${visibility === "public"
                                        ? "bg-green-900/30 text-green-400 border border-green-700/30"
                                        : "bg-purple-900/30 text-purple-400 border border-purple-700/30"
                                        }`}>
                                        {visibility === "public" ? "üåç Public" : "üîí Protected"}
                                    </span>
                                </div>
                                <CacheStatus />
                            </div>

                            {(processedVideoUrl.current || editData?.videoUrl) && (
                                <div className="relative mb-6 group">
                                    <video
                                        key={processedVideo ? 'processed-video' : 'original-video'}
                                        controls
                                        className="rounded-xl w-full h-96 object-contain shadow-md transition-all duration-300 bg-black"
                                        src={processedVideoUrl.current || editData?.videoUrl}
                                        poster={thumbnailPreview || undefined}
                                    />

                                    {/* Show trimming info */}
                                    {videoDuration > 30 && (
                                        <div className="absolute top-3 left-3 bg-amber-600 text-white text-xs px-2 py-1 rounded-full shadow-md">
                                            ‚úÇÔ∏è Trimmed to 30s
                                        </div>
                                    )}

                                    {processingState === 'processing' && (
                                        <div className="absolute inset-0 bg-black/70 flex flex-col items-center justify-center rounded-xl">
                                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white mb-2"></div>
                                            <p className="text-white text-sm">Processing... {Math.round(processingProgress)}%</p>
                                        </div>
                                    )}

                                    {processingState === 'completed' && (
                                        <div className="absolute top-3 right-3 bg-green-600 text-white text-xs px-2 py-1 rounded-full shadow-md">
                                            {editData?.isEditMode ? 'Existing Video' : 'Ready'}
                                        </div>
                                    )}
                                </div>
                            )}

                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                                <div className="p-4 bg-gray-700/50 rounded-xl shadow-sm border border-gray-600">
                                    <h3 className="text-sm font-medium text-gray-400 mb-2">Caption</h3>
                                    <p className="text-gray-200 break-words whitespace-pre-wrap bg-gray-800/30 p-3 rounded-lg w-full">
                                        {caption || <span className="text-gray-500 italic">No caption provided</span>}
                                    </p>
                                </div>

                                {tags && (
                                    <div className="p-4 bg-gray-700/50 rounded-xl shadow-sm border border-gray-600">
                                        <h3 className="text-sm font-medium text-gray-400 mb-2">Tags</h3>
                                        <div className="flex flex-wrap gap-2">
                                            {tags.split(",").map((tag, index) => (
                                                tag.trim() && (
                                                    <span
                                                        key={index}
                                                        className="px-3 py-1 bg-gradient-to-r from-blue-900/50 to-purple-900/50 text-blue-200 rounded-full text-xs font-medium shadow-sm border border-blue-700/30"
                                                    >
                                                        #{tag.trim()}
                                                    </span>
                                                )
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>

                            {thumbnailState !== 'idle' && (
                                <div className="mb-6 p-4 bg-gray-700/50 rounded-xl border border-gray-600">
                                    <h3 className="text-sm font-medium text-gray-400 mb-3">Thumbnail</h3>

                                    {thumbnailPreview ? (
                                        <div className="relative mb-3">
                                            <img
                                                src={thumbnailPreview}
                                                alt="Thumbnail preview"
                                                className="rounded-lg w-full h-40 object-cover border border-gray-600 shadow-md"
                                            />
                                            <div className="absolute bottom-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded">
                                                {thumbnail ? `${(thumbnail.size / 1024).toFixed(0)}KB` : ''}
                                            </div>
                                            <button
                                                type="button"
                                                onClick={removeThumbnail}
                                                className="absolute top-2 right-2 p-1.5 bg-red-600 text-white rounded-full hover:bg-red-700 shadow-md transition-colors"
                                            >
                                                <CloseIcon />
                                            </button>
                                        </div>
                                    ) : thumbnailState === 'generating' ? (
                                        <div className="flex items-center justify-center h-32 bg-gray-800/30 rounded-lg border border-gray-600">
                                            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-white mr-2"></div>
                                            <span className="text-gray-300">Generating thumbnail...</span>
                                        </div>
                                    ) : null}
                                </div>
                            )}

                            <div className="mb-6 p-4 bg-gray-700/50 rounded-xl shadow-sm border border-gray-600">
                                <h3 className="text-sm font-medium text-gray-400 mb-3">Video Details</h3>
                                <div className="grid grid-cols-2 gap-3 text-sm">
                                    <div className="text-gray-400">Original Duration:</div>
                                    <div className="text-gray-200">{formatTime(videoDuration)}</div>

                                    <div className="text-gray-400">Final Duration:</div>
                                    <div className="text-gray-200">
                                        {formatTime(Math.min(videoDuration, 30))}
                                        {videoDuration > 30 && (
                                            <span className="text-amber-300 text-xs ml-1">(trimmed)</span>
                                        )}
                                    </div>

                                    <div className="text-gray-400">Original Size:</div>
                                    <div className="text-gray-200">{video && VideoCompressionUtility.formatBytes(video.size)}</div>

                                    {processingResult && processingResult.processedSize !== processingResult.originalSize && (
                                        <>
                                            <div className="text-gray-400">Compressed Size:</div>
                                            <div className="text-green-400">
                                                {VideoCompressionUtility.formatBytes(processingResult.processedSize)}
                                                <span className="text-xs text-gray-500 ml-1">
                                                    ({(100 - (processingResult.processedSize / processingResult.originalSize * 100)).toFixed(1)}% reduction)
                                                </span>
                                            </div>
                                        </>
                                    )}

                                    {processingResult?.resolution && (
                                        <>
                                            <div className="text-gray-400">Resolution:</div>
                                            <div className="text-gray-200">{processingResult.resolution}</div>
                                        </>
                                    )}
                                </div>
                            </div>

                            <div className="flex justify-between mt-8 pt-4 border-t border-gray-700">
                                <button
                                    onClick={() => setPreviewMode(false)}
                                    className="flex items-center gap-2 px-5 py-2.5 border border-purple-600 bg-purple-700 text-white rounded-xl hover:bg-purple-800 hover:border-purple-500 transition-colors"
                                >
                                    <EditIcon />
                                    Edit Reel
                                </button>
                                <button
                                    onClick={handleSubmit}
                                    disabled={isSubmitting}
                                    className="flex items-center gap-2 px-6 py-2.5 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-xl hover:from-blue-700 hover:to-purple-700 shadow-lg hover:shadow-blue-500/20 transition-all disabled:opacity-50 min-w-[140px] justify-center"
                                >
                                    {isSubmitting ? (
                                        editData?.isEditMode ? (
                                            <>
                                                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
                                                {uploadState === 'getting_url' && 'Preparing...'}
                                                {uploadState === 'saving_metadata' && 'Updating...'}
                                                {uploadState === 'completed' && '‚úì Updated!'}
                                                {uploadState === 'error' && 'Failed!'}
                                            </>
                                        ) : (
                                            <>
                                                {uploadState === 'getting_url' && 'Preparing...'}
                                                {uploadState === 'uploading_video' && `Uploading ${Math.round(uploadProgress)}%`}
                                                {uploadState === 'uploading_thumbnail' && 'Uploading Thumbnail...'}
                                                {uploadState === 'saving_metadata' && 'Finalizing...'}
                                                {uploadState === 'completed' && 'Success!'}
                                                {uploadState === 'error' && 'Failed!'}
                                            </>
                                        )
                                    ) : (
                                        <>
                                            <SendIcon />
                                            {editData?.isEditMode ? 'Update Reel' : 'Post Reel'}
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        );
    }

    return (
        <div className={isModal ? "" : "min-h-screen bg-gradient-to-br from-gray-900 to-black"}>
            <div className={isModal ? "" : "max-w-4xl mx-auto"}>
                <div className={`bg-gray-800 rounded-2xl shadow-2xl border border-gray-700 overflow-hidden transition-all duration-300 hover:shadow-blue-500/10 ${isModal ? 'rounded-t-xl sm:rounded-xl' : ''}`}>
                    {!isModal && <div className="h-2 bg-gradient-to-r from-blue-600 to-purple-600"></div>}
                    <div className="p-6">
                        <h2 className="text-2xl font-bold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-400">
                            {editData?.isEditMode ? 'Edit Reel' : 'Upload Reel'}
                        </h2>

                        <div className="space-y-5">
                            {/* Video Upload */}
                            <div className="relative">
                                <input type="file" accept="video/*" onChange={handleVideoChange} id="video-upload" className="hidden" />
                                <label htmlFor="video-upload" className={`block p-8 border-2 border-dashed rounded-2xl text-center cursor-pointer transition-all hover:bg-gray-700/30 ${errors.video ? 'border-red-500 bg-red-900/20' : 'border-gray-600 hover:border-blue-500'}`}>
                                    <div className="flex flex-col items-center justify-center gap-3">
                                        <div className={`p-3 rounded-full ${errors.video ? 'bg-red-800/50' : 'bg-gray-700'}`}>
                                            <VideoIcon />
                                        </div>
                                        <span className={`font-medium ${errors.video ? 'text-red-300' : 'text-blue-300'}`}>
                                            {video ? "Change Video" : "Upload Video"}
                                        </span>
                                        <span className="text-sm text-gray-400">
                                            MP4, MOV up to {MAX_SIZE_MB}MB
                                        </span>
                                        <div className="text-xs text-gray-500 mt-2">
                                            Videos will be automatically optimized for best delivery
                                        </div>
                                    </div>
                                </label>

                                {errors.video && (
                                    <p className="text-red-400 text-sm mt-2 flex items-center">
                                        <span className="w-4 h-4 bg-red-500 rounded-full flex items-center justify-center text-xs mr-1">!</span>
                                        {errors.video}
                                    </p>
                                )}

                                {video && (
                                    <div className="mt-4 p-4 bg-gray-700 rounded-xl shadow-sm flex items-center justify-between border border-gray-600">
                                        <div className="flex items-center gap-3">
                                            <VideoIcon />
                                            <div>
                                                <span className="text-sm font-medium text-gray-200 truncate max-w-xs block">
                                                    {editData?.isEditMode ? (editData.cachedVideo ? 'Cached Video' : 'Existing Video') : video.name}
                                                </span>
                                                <span className="text-xs text-gray-400">
                                                    {editData?.isEditMode
                                                        ? (editData.cachedVideo ? 'Ready for editing' : 'Streaming from cloud')
                                                        : `${formatBytes(video.size)} ‚Ä¢ ${formatTime(videoDuration)}`
                                                    }
                                                </span>
                                                {(processingState === 'completed' || editData?.isEditMode) && (
                                                    <span className="text-xs text-green-400">
                                                        {editData?.isEditMode
                                                            ? (editData.cachedVideo ? '‚úì Local copy ready' : '‚úì Cloud video loaded')
                                                            : '‚úì Optimized for delivery'
                                                        }
                                                    </span>
                                                )}
                                            </div>
                                        </div>
                                        {!editData?.isEditMode && (
                                            <button onClick={removeVideo} className="p-1 text-gray-400 hover:text-red-400 transition-colors" disabled={processingState === 'processing'}>
                                                <CloseIcon />
                                            </button>
                                        )}
                                    </div>
                                )}

                                {processingState === 'processing' && (
                                    <div className="p-4 bg-blue-900/20 border border-blue-700/30 rounded-lg mt-3">
                                        <div className="flex items-center justify-between mb-2">
                                            <span className="text-blue-300 font-medium">Optimizing Video</span>
                                            <span className="text-blue-400 text-sm">{Math.round(processingProgress)}%</span>
                                        </div>
                                        <div className="w-full bg-blue-900/30 rounded-full h-2">
                                            <div className="bg-blue-500 h-2 rounded-full transition-all duration-300" style={{ width: `${processingProgress}%` }}></div>
                                        </div>
                                        <p className="text-blue-200 text-xs mt-2">Trimming and compressing for optimal delivery</p>
                                    </div>
                                )}

                                {processingState === 'completed' && processingResult && (
                                    <div className="p-4 bg-green-900/20 border border-green-700/30 rounded-lg mt-3">
                                        <div className="flex items-center justify-between">
                                            <span className="text-green-300 font-medium">‚úì Optimization Complete</span>
                                            <span className="text-green-400 text-sm">
                                                {VideoCompressionUtility.formatBytes(processingResult.processedSize)}
                                            </span>
                                        </div>
                                        <div className="text-green-200 text-xs mt-1">
                                            {videoDuration > 30 && (
                                                <span className="text-amber-300">‚úÇÔ∏è Trimmed to 30 seconds</span>
                                            )}
                                            {!videoDuration || videoDuration <= 30 && (
                                                <span>‚úÖ Ready for upload</span>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>

                            {/* Caption Input */}
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-2">
                                    Caption <span className="text-red-400">*</span>
                                </label>
                                <textarea
                                    value={caption}
                                    onChange={handleCaptionChange}
                                    placeholder="Write a caption for your reel..."
                                    className={`w-full p-3 rounded-lg bg-gray-700 text-white border ${errors.caption ? "border-red-500" : "border-gray-600"} focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 transition-colors`}
                                    rows={3}
                                />
                                <div className="flex justify-between text-xs mt-1">
                                    <span className={errors.caption ? "text-red-400" : "text-gray-400"}>{errors.caption || ""}</span>
                                    <span className="text-gray-400">{caption.length}/{MAX_CAPTION_LENGTH}</span>
                                </div>
                            </div>

                            {/* Thumbnail Section */}
                            <div className="mt-6">
                                <label className="block text-sm font-medium text-gray-300 mb-2">
                                    Thumbnail
                                    <span className="text-xs text-gray-400 ml-2">(Optional - auto-generated if not provided)</span>
                                </label>

                                {thumbnailPreview ? (
                                    <div className="relative w-full max-w-sm mx-auto">
                                        <img src={thumbnailPreview} alt="Thumbnail preview" className="rounded-lg w-full h-40 object-cover border border-gray-600 shadow-md" />
                                        <div className="absolute bottom-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded">
                                            {thumbnail ? `${(thumbnail.size / 1024).toFixed(0)}KB` : ''}
                                        </div>
                                        <button type="button" onClick={removeThumbnail} className="absolute top-2 right-2 p-1.5 bg-red-600 text-white rounded-full hover:bg-red-700 shadow-md">
                                            <CloseIcon />
                                        </button>
                                    </div>
                                ) : (
                                    <label htmlFor="thumbnail-upload" className="block cursor-pointer w-full max-w-sm mx-auto p-4 bg-gray-700 rounded-lg border border-gray-600 hover:bg-gray-600 text-center transition-all flex items-center justify-center gap-2">
                                        <ImageIcon />
                                        <span className="text-gray-200 font-medium">Upload Custom Thumbnail</span>
                                        <span className="text-xs text-gray-400 block mt-1">(Max 1MB)</span>
                                    </label>
                                )}

                                <input type="file" accept="image/*" onChange={handleThumbnailChange} id="thumbnail-upload" className="hidden" />
                            </div>

                            {/* Tags Input */}
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-2">
                                    Tags <span className="text-red-400">*</span>
                                    <span className="text-xs text-gray-400 ml-2">(comma separated)</span>
                                </label>
                                <p className="text-xs text-gray-400 mb-2">Each tag ‚â§ {MAX_TAG_LENGTH} chars, max {MAX_TAGS_COUNT} tags</p>
                                <input
                                    type="text"
                                    value={tags}
                                    onChange={handleTagsChange}
                                    placeholder="Enter tags separated by commas (e.g., funny, meme, viral)"
                                    className={`w-full p-3 rounded-lg bg-gray-700 text-white border ${errors.tags ? "border-red-500" : "border-gray-600"} focus:border-blue-500 focus:ring-2 focus:ring-blue-500/20 transition-colors`}
                                />
                                <div className="flex flex-wrap gap-2 mt-2">
                                    {tags.split(",").map((tag, i) => {
                                        const cleanTag = tag.trim();
                                        if (!cleanTag) return null;
                                        const tooLong = cleanTag.length > MAX_TAG_LENGTH;
                                        return (
                                            <span key={i} className={`px-3 py-1 rounded-full text-sm ${tooLong ? "bg-red-800 text-red-200 border border-red-500" : "bg-blue-900 text-blue-200 border border-blue-700/30"}`}>
                                                #{cleanTag}
                                            </span>
                                        );
                                    })}
                                </div>
                                <div className="flex justify-between text-xs mt-1">
                                    <span className={errors.tags ? "text-red-400" : "text-gray-400"}>{errors.tags || ""}</span>
                                    <span className="text-gray-400">{tags.split(",").filter(t => t.trim()).length}/{MAX_TAGS_COUNT} tags</span>
                                </div>
                            </div>
                        </div>
                        <VisibilityToggle />
                        {renderActions()}

                        {!video && !editData?.isEditMode && !errors.video && (
                            <p className="text-center text-sm text-amber-400 mt-3">Please upload a video to continue</p>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
}







import boto3
import json
import os
from uuid import uuid4

s3_client = boto3.client("s3")
BUCKET_NAME = os.environ.get("BUCKET_NAME", "crinzcontent")

def lambda_handler(event, context):
    try:
        # CORS preflight
        if event.get('httpMethod') == 'OPTIONS':
            return cors_response()
            
        headers = {k.lower(): v for k, v in event.get('headers', {}).items()}
        auth_header = headers.get('authorization', '')
        
        if not auth_header.startswith('Bearer '):
            return error_response("Unauthorized", 401)

        try:
            body_data = json.loads(event.get('body', '{}'))
        except json.JSONDecodeError:
            return error_response("Invalid JSON", 400)

        filename = body_data.get("filename")
        filetype = body_data.get("filetype")
        purpose = body_data.get("purpose", "reel_video")
        
        if not filename or not filetype:
            return error_response("filename and filetype required", 400)

        # Extract user ID from JWT claims
        claims = (
            event.get("requestContext", {}).get("authorizer", {}).get("jwt", {}).get("claims")
            or event.get("requestContext", {}).get("authorizer", {}).get("claims", {})
        )
        user_id = claims.get("sub") if claims else None
        
        if not user_id:
            return error_response("User ID not found", 401)

        # Generate unique ID and key
        unique_id = str(uuid4())
        file_extension = os.path.splitext(filename)[1] or '.mp4'
        
        # Create appropriate S3 key based on purpose
        if purpose == "reel_thumbnail":
            key = f"{user_id}/reels/thumbnails/{unique_id}{file_extension}"
        else:
            key = f"{user_id}/reels/{unique_id}{file_extension}"

        # Generate presigned URL
        presigned_url = s3_client.generate_presigned_url(
            "put_object",
            Params={
                "Bucket": BUCKET_NAME, 
                "Key": key, 
                "ContentType": filetype
            },
            ExpiresIn=3600
        )

        return success_response({
            "url": presigned_url, 
            "key": key, 
            "reelId": unique_id
        })

    except Exception as e:
        print(f"Error: {str(e)}")
        return error_response("Internal server error", 500)

def cors_response():
    return {
        "statusCode": 200,
        "headers": cors_headers(),
        "body": json.dumps({"message": "CORS preflight"})
    }

def success_response(data):
    return {
        "statusCode": 200,
        "body": json.dumps(data),
        "headers": cors_headers()
    }

def error_response(message, status_code=400):
    return {
        "statusCode": status_code,
        "body": json.dumps({"error": message}),
        "headers": cors_headers()
    }

def cors_headers():
    return {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "Content-Type,Authorization,X-Amz-Date,X-Api-Key,X-Amz-Security-Token",
        "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS"
    }






    import json
import os
import time
import boto3
import base64
from uuid import uuid4
from botocore.exceptions import ClientError

s3 = boto3.client("s3")
dynamodb = boto3.resource("dynamodb")
BUCKET_NAME = os.environ.get("CRINZ_S3_BUCKET", "crinzcontent")
TABLE_NAME = os.environ.get("CRINZ_DYNAMO_TABLE", "CrinzContent")
table = dynamodb.Table(TABLE_NAME)

def lambda_handler(event, context):
    try:
        http_method = event.get("httpMethod", "POST")
        
        if http_method == "OPTIONS":
            return cors_response()
            
        if http_method == "POST":
            return handle_post_request(event)
        else:
            return error_response("Method not allowed")

    except Exception as e:
        print("Error:", e)
        return error_response(str(e))

def handle_post_request(event):
    body = parse_body(event)
    action = body.get("action")
    
    if not action:
        return error_response("action field is required")
    
    action_handlers = {
        "POSTCREATE": create_post,
        "POSTUPDATE": update_post,
        "POSTDELETE": delete_post,
        "REELCREATE": create_reel,
        "REELUPDATE": update_reel,
        "REELDELETE": delete_reel
    }
    
    handler = action_handlers.get(action)
    if not handler:
        return error_response(f"Invalid action: {action}")
    
    return handler(body, event)

def parse_body(event):
    body = event.get("body", {})
    if isinstance(body, str):
        try:
            return json.loads(body)
        except json.JSONDecodeError:
            return {}
    return body

def get_user_id(event):
    claims = (
        event.get("requestContext", {})
        .get("authorizer", {})
        .get("jwt", {})
        .get("claims")
        or event.get("requestContext", {})
        .get("authorizer", {})
        .get("claims", {})
    )
    return claims.get("sub") if claims else None

def create_reel(body, event):
    metadata = body.get("metadata", {})
    
    user_id = get_user_id(event)
    if not user_id:
        return error_response("User ID not found")

    reel_file = metadata.get("reelFile")
    if not reel_file or not reel_file.get("s3Key"):
        return error_response("reelFile with s3Key required")

    reel_id = metadata.get("reelId", str(uuid4()))
    post_id = str(uuid4())
    timestamp = int(time.time() * 1000)
    
    # Build files array
    files = [{
        "fileName": reel_file.get("fileName", ""),
        "s3Key": reel_file.get("s3Key"),
        "type": reel_file.get("type", "video/mp4"),
        "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{reel_file.get('s3Key')}"
    }]
    
    # Add thumbnail if provided
    thumbnail = metadata.get("thumbnail")
    if thumbnail and thumbnail.get("s3Key"):
        files.append({
            "fileName": thumbnail.get("fileName", ""),
            "s3Key": thumbnail.get("s3Key"),
            "type": thumbnail.get("type", "image/jpeg"),
            "isCustom": True,
            "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{thumbnail.get('s3Key')}"
        })
    
    # Parse tags
    tags_input = metadata.get("tags", "")
    if isinstance(tags_input, list):
        tags = [tag.strip() for tag in tags_input if tag.strip()]
    else:
        tags = [tag.strip() for tag in str(tags_input).split(",") if tag.strip()]
    
    # Create DynamoDB item
    item = {
        "pk": f"USER#{user_id}",
        "sk": f"POST#{post_id}",
        "postId": post_id,
        "reelId": reel_id,
        "userId": user_id,
        "timestamp": timestamp,
        "type": "crinzpostsreels",
        "caption": metadata.get("caption", ""),
        "tags": tags,
        "visibility": metadata.get("visibility", "public"),
        "likes": 0,
        "comments": 0,
        "files": files,
        "imageCount": len([f for f in files if f["type"].startswith("image")]),
        "hasAudio": any(f["type"].startswith("audio") for f in files)
    }

    try:
        table.put_item(Item=item)
        return success_response({
            "message": "Reel created successfully", 
            "postId": post_id,
            "reelId": reel_id
        })
    except ClientError as e:
        return error_response(f"Failed to create reel: {str(e)}")

def update_reel(body, event):
    post_id = body.get("postId")
    if not post_id:
        return error_response("postId is required")

    user_id = get_user_id(event)
    if not user_id:
        return error_response("User ID not found")

    # Get existing reel
    try:
        response = table.get_item(
            Key={"pk": f"USER#{user_id}", "sk": f"POST#{post_id}"}
        )
        existing_reel = response.get("Item")
        if not existing_reel:
            return error_response("Reel not found")
    except ClientError as e:
        return error_response("Failed to fetch reel")

    # Verify ownership and type
    if existing_reel.get("userId") != user_id:
        return error_response("Not authorized to update this reel")
    if existing_reel.get("type") != "crinzpostsreels":
        return error_response("Can only update reel posts with this action")

    metadata = body.get("metadata", {})
    timestamp = int(time.time() * 1000)
    
    # Build update expression
    update_expr_parts = ["SET #timestamp = :timestamp"]
    expr_names = {"#timestamp": "timestamp"}
    expr_values = {":timestamp": timestamp}
    
    # Update caption
    if "caption" in metadata:
        update_expr_parts.append("#caption = :caption")
        expr_names["#caption"] = "caption"
        expr_values[":caption"] = metadata.get("caption")
    
    # Update tags
    if "tags" in metadata:
        tags_input = metadata.get("tags", "")
        if isinstance(tags_input, list):
            tags = [tag.strip() for tag in tags_input if tag.strip()]
        else:
            tags = [tag.strip() for tag in str(tags_input).split(",") if tag.strip()]
        
        update_expr_parts.append("#tags = :tags")
        expr_names["#tags"] = "tags"
        expr_values[":tags"] = tags
    
    # Update visibility
    if "visibility" in metadata:
        update_expr_parts.append("#visibility = :visibility")
        expr_names["#visibility"] = "visibility"
        expr_values[":visibility"] = metadata.get("visibility")
    
    # Handle file updates
    files = existing_reel.get("files", [])
    files_updated = False
    
    # Update thumbnail
    thumbnail = metadata.get("thumbnail")
    if thumbnail and thumbnail.get("s3Key"):
        # Remove existing custom thumbnails
        files = [f for f in files if not f.get("isCustom")]
        
        # Add new thumbnail
        files.append({
            "fileName": thumbnail.get("fileName", ""),
            "s3Key": thumbnail.get("s3Key"),
            "type": thumbnail.get("type", "image/jpeg"),
            "isCustom": True,
            "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{thumbnail.get('s3Key')}"
        })
        files_updated = True
    
    # Update video
    reel_file = metadata.get("reelFile")
    if reel_file and reel_file.get("s3Key"):
        # Remove existing video
        files = [f for f in files if not f["type"].startswith("video")]
        
        # Add new video
        files.append({
            "fileName": reel_file.get("fileName", ""),
            "s3Key": reel_file.get("s3Key"),
            "type": reel_file.get("type", "video/mp4"),
            "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{reel_file.get('s3Key')}"
        })
        files_updated = True
    
    if files_updated:
        update_expr_parts.append("#files = :files")
        update_expr_parts.append("#imageCount = :imageCount")
        expr_names["#files"] = "files"
        expr_names["#imageCount"] = "imageCount"
        expr_values[":files"] = files
        expr_values[":imageCount"] = len([f for f in files if f["type"].startswith("image")])
    
    try:
        table.update_item(
            Key={"pk": f"USER#{user_id}", "sk": f"POST#{post_id}"},
            UpdateExpression=", ".join(update_expr_parts),
            ExpressionAttributeNames=expr_names,
            ExpressionAttributeValues=expr_values
        )
        
        return success_response({
            "message": "Reel updated successfully", 
            "postId": post_id
        })
    except ClientError as e:
        return error_response(f"Failed to update reel: {str(e)}")

def delete_reel(body, event):
    post_id = body.get("postId")
    if not post_id:
        return error_response("postId is required")

    user_id = get_user_id(event)
    if not user_id:
        return error_response("User ID not found")

    # Get existing reel
    try:
        response = table.get_item(
            Key={"pk": f"USER#{user_id}", "sk": f"POST#{post_id}"}
        )
        existing_reel = response.get("Item")
        if not existing_reel:
            return error_response("Reel not found")
    except ClientError as e:
        return error_response("Failed to fetch reel")

    # Verify ownership
    if existing_reel.get("userId") != user_id:
        return error_response("Not authorized to delete this reel")

    # Delete files from S3
    files = existing_reel.get("files", [])
    files_deleted = 0
    
    for file_data in files:
        try:
            s3.delete_object(Bucket=BUCKET_NAME, Key=file_data.get("s3Key"))
            files_deleted += 1
        except ClientError as e:
            print(f"Failed to delete file: {e}")

    # Delete all likes for this reel
    likes_deleted = 0
    try:
        # Query likes table for all likes on this reel
        likes_table = dynamodb.Table("CrinzLikes")
        response = likes_table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key("crinzId").eq(post_id)
        )
        
        # Batch delete all likes
        with likes_table.batch_writer() as batch:
            for like in response.get('Items', []):
                batch.delete_item(
                    Key={
                        "crinzId": like["crinzId"],
                        "userId": like["userId"]
                    }
                )
                likes_deleted += 1
                
        print(f"Deleted {likes_deleted} likes for reel {post_id}")
    except ClientError as e:
        print(f"Failed to delete likes: {e}")

    # Delete all comments for this reel
    comments_deleted = 0
    try:
        # Query comments table for all comments on this reel
        comments_table = dynamodb.Table("CrinzComments")
        response = comments_table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key("crinzId").eq(post_id)
        )
        
        # Batch delete all comments
        with comments_table.batch_writer() as batch:
            for comment in response.get('Items', []):
                batch.delete_item(
                    Key={
                        "crinzId": comment["crinzId"],
                        "commentId": comment["commentId"]
                    }
                )
                comments_deleted += 1
                
        print(f"Deleted {comments_deleted} comments for reel {post_id}")
    except ClientError as e:
        print(f"Failed to delete comments: {e}")

    # Delete from DynamoDB
    try:
        table.delete_item(Key={"pk": f"USER#{user_id}", "sk": f"POST#{post_id}"})
        return success_response({
            "message": "Reel deleted successfully", 
            "postId": post_id,
            "filesDeleted": files_deleted,
            "likesDeleted": likes_deleted,
            "commentsDeleted": comments_deleted
        })
    except ClientError as e:
        return error_response(f"Failed to delete reel: {str(e)}")

def success_response(data):
    return {
        "statusCode": 200,
        "body": json.dumps(data),
        "headers": cors_headers()
    }

def error_response(message):
    return {
        "statusCode": 400,
        "body": json.dumps({"error": message}),
        "headers": cors_headers()
    }

def cors_headers():
    return {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",  # Or specific domain: "http://localhost:5173"
        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token",
        "Access-Control-Allow-Credentials": "true"  # Add this if using credentials
    }

def cors_response():
    return {
        "statusCode": 200,
        "headers": cors_headers(),
        "body": json.dumps({"message": "CORS preflight"})
    }

def create_post(body, event):
    """Create a new meme/post"""
    files = body.get("files", [])
    metadata = body.get("metadata", {})

    user_id = get_user_id(event)
    if not user_id:
        return error_response("user id not found")

    post_id = str(uuid4())
    timestamp = int(time.time() * 1000)
    uploaded_files = []

    # meme/image case: lambda uploads base64 files
    for f in files:
        # S3 key structure: user_id/post_id/filename
        key = f"{user_id}/{post_id}/{f['name']}"
        file_content = base64.b64decode(f["contentBase64"])
        s3.put_object(Bucket=BUCKET_NAME, Key=key, Body=file_content)
        uploaded_files.append({
            "fileName": f["name"], 
            "s3Key": key, 
            "type": f["type"],
            "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{key}"
        })

    # dynamodb item
    item = {
        "pk": f"USER#{user_id}",
        "sk": f"POST#{post_id}",
        "postId": post_id,
        "userId": user_id,
        "timestamp": timestamp,
        "type": "crinzpostsmeme",
        "caption": metadata.get("caption", ""),
        "tags": [t.strip() for t in metadata.get("tags", "").split(",") if t.strip()],
        "visibility": metadata.get("visibility", "public"),
        "likes": 0,
        "comments": 0,
        "files": uploaded_files,
        "imageCount": len([f for f in uploaded_files if f["type"].startswith("image")]),
        "hasAudio": any(f["type"].startswith("audio") for f in uploaded_files)
    }

    table.put_item(Item=item)

    return success_response({"message": "post created successfully", "postId": post_id})

def update_post(body, event):
    """Update an existing post"""
    post_id = body.get("postId")
    if not post_id:
        return error_response("postId is required")

    user_id = get_user_id(event)
    if not user_id:
        return error_response("user id not found")

    # Get existing post
    try:
        response = table.get_item(
            Key={
                "pk": f"USER#{user_id}",
                "sk": f"POST#{post_id}"
            }
        )
        existing_post = response.get("Item")
        if not existing_post:
            return error_response("Post not found")
    except ClientError as e:
        return error_response("Failed to fetch post")

    # Verify ownership and type
    if existing_post.get("userId") != user_id:
        return error_response("Not authorized to update this post")
    if existing_post.get("type") != "crinzpostsmeme":
        return error_response("Can only update meme posts with this action")

    # Process files - handle mixed existing and new files
    files = body.get("files", [])
    updated_files = []
    new_files_uploaded = []

    for file_data in files:
        if "contentBase64" in file_data:
            # New file - upload to S3
            key = f"{user_id}/{post_id}/{file_data['name']}"
            file_content = base64.b64decode(file_data["contentBase64"])
            s3.put_object(Bucket=BUCKET_NAME, Key=key, Body=file_content)
            new_file = {
                "fileName": file_data["name"], 
                "s3Key": key, 
                "type": file_data["type"],
                "url": f"https://{BUCKET_NAME}.s3.amazonaws.com/{key}"
            }
            updated_files.append(new_file)
            new_files_uploaded.append(new_file)
        else:
            # Existing file - keep as-is
            updated_files.append(file_data)

    # Delete old files that were removed
    existing_files = existing_post.get("files", [])
    files_to_delete = []
    
    for existing_file in existing_files:
        file_still_exists = any(
            updated_file.get("s3Key") == existing_file.get("s3Key") 
            for updated_file in updated_files
        )
        if not file_still_exists:
            files_to_delete.append(existing_file)

    # Delete removed files from S3
    for file_to_delete in files_to_delete:
        try:
            s3.delete_object(Bucket=BUCKET_NAME, Key=file_to_delete.get("s3Key"))
            print(f"Deleted file: {file_to_delete.get('s3Key')}")
        except ClientError as e:
            print(f"Failed to delete file {file_to_delete.get('s3Key')}: {e}")

    # Update timestamp
    timestamp = int(time.time() * 1000)

    # Update item in DynamoDB
    update_expression = """
        SET #caption = :caption, 
            #tags = :tags, 
            #files = :files, 
            #timestamp = :timestamp,
            #imageCount = :imageCount,
            #hasAudio = :hasAudio
    """
    expression_attribute_names = {
        "#caption": "caption",
        "#tags": "tags",
        "#files": "files",
        "#timestamp": "timestamp",
        "#imageCount": "imageCount",
        "#hasAudio": "hasAudio"
    }
    expression_attribute_values = {
        ":caption": body.get("caption", existing_post.get("caption", "")),
        ":tags": body.get("tags", existing_post.get("tags", [])),
        ":files": updated_files,
        ":timestamp": timestamp,
        ":imageCount": len([f for f in updated_files if f["type"].startswith("image")]),
        ":hasAudio": any(f["type"].startswith("audio") for f in updated_files)
    }

    try:
        table.update_item(
            Key={
                "pk": f"USER#{user_id}",
                "sk": f"POST#{post_id}"
            },
            UpdateExpression=update_expression,
            ExpressionAttributeNames=expression_attribute_names,
            ExpressionAttributeValues=expression_attribute_values
        )
    except ClientError as e:
        return error_response("Failed to update post")

    return success_response({
        "message": "post updated successfully", 
        "postId": post_id,
        "filesUpdated": len(new_files_uploaded),
        "filesDeleted": len(files_to_delete)
    })

def delete_post(body, event):
    """Delete a post and its associated files, likes, and comments"""
    post_id = body.get("postId")
    
    if not post_id:
        return error_response("postId is required")

    user_id = get_user_id(event)
    if not user_id:
        return error_response("user id not found")

    # Get existing post to find files to delete from S3
    try:
        response = table.get_item(
            Key={
                "pk": f"USER#{user_id}",
                "sk": f"POST#{post_id}"
            }
        )
        existing_post = response.get("Item")
        if not existing_post:
            return error_response("Post not found")
    except ClientError as e:
        return error_response("Failed to fetch post")

    # Verify ownership and type
    if existing_post.get("userId") != user_id:
        return error_response("Not authorized to delete this post")
    if existing_post.get("type") != "crinzpostsmeme":
        return error_response("Can only delete meme posts with this action")

    # Delete files from S3
    files = existing_post.get("files", [])
    files_deleted = 0
    for file_data in files:
        try:
            s3.delete_object(Bucket=BUCKET_NAME, Key=file_data.get("s3Key"))
            files_deleted += 1
            print(f"Deleted file: {file_data.get('s3Key')}")
        except ClientError as e:
            print(f"Failed to delete file {file_data.get('s3Key')}: {e}")

    # Delete all likes for this post
    likes_deleted = 0
    try:
        likes_table = dynamodb.Table("CrinzLikes")
        response = likes_table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key("crinzId").eq(post_id)
        )
        
        with likes_table.batch_writer() as batch:
            for like in response.get('Items', []):
                batch.delete_item(
                    Key={
                        "crinzId": like["crinzId"],
                        "userId": like["userId"]
                    }
                )
                likes_deleted += 1
                
        print(f"Deleted {likes_deleted} likes for post {post_id}")
    except ClientError as e:
        print(f"Failed to delete likes: {e}")

    # Delete all comments for this post
    comments_deleted = 0
    try:
        comments_table = dynamodb.Table("CrinzComments")
        response = comments_table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key("crinzId").eq(post_id)
        )
        
        with comments_table.batch_writer() as batch:
            for comment in response.get('Items', []):
                batch.delete_item(
                    Key={
                        "crinzId": comment["crinzId"],
                        "commentId": comment["commentId"]
                    }
                )
                comments_deleted += 1
                
        print(f"Deleted {comments_deleted} comments for post {post_id}")
    except ClientError as e:
        print(f"Failed to delete comments: {e}")

    # Delete item from DynamoDB
    try:
        table.delete_item(
            Key={
                "pk": f"USER#{user_id}",
                "sk": f"POST#{post_id}"
            }
        )
    except ClientError as e:
        return error_response("Failed to delete post")

    return success_response({
        "message": "post deleted successfully", 
        "postId": post_id,
        "filesDeleted": files_deleted,
        "likesDeleted": likes_deleted,
        "commentsDeleted": comments_deleted
    })